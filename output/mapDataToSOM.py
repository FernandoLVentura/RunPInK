import numpy as np
import struct
from astropy.io import fits
from astropy.table import Table
import warnings


from makeHMAP import *


# This script collects the relevant data from the SDSS VAC and compiles the means and stand deviations.
# It then uses makeHMAP to create heatmaps of the output.

# Important variables:
imageSize = 128                             # Square image sidelength (pixels)
stampDimensions = [imageSize, imageSize]

mapping_file = 'stampmap150k.bin'           # Path to Mapping file created by PINK.
imageCat = 'stampCat2.csv'                  # Path to Catalogue created by stamp collector

                                            # Path to VAC containing stellar mass and other properties.
smassCat = 'portsmouth_stellarmass_passive_krou-DR12.fits'

numPrototypes = 91                          # Number of prototypes in SOM

precision = 6.0/(60*60)                     # 6 arcsecond precision, deg. 

print("Reading mapping...")

# Read in the mapping file generated by pink
# Cannot use map width and height directly as not a rectangular map
with open(mapping_file, 'rb') as instr:
	numImgs = struct.unpack("i", instr.read(4))[0]
	mWidth = struct.unpack("i", instr.read(4))[0]
	mHeight = struct.unpack("i", instr.read(4))[0]
	mDepth = struct.unpack("i", instr.read(4))[0]
	
	mapping = np.ones((numImgs, numPrototypes))
	for i in range(numImgs):
		for t in range(numPrototypes):
			mapping[i, t] = struct.unpack_from("f", instr.read(4))[0]
			
print("Mapping read:")
print( str(mapping.shape) + " being images by prototypes. Classing images:")

# Get the appropriate prototype for each image as well as an indication of how
# well each prototype works and which images match their prototypes the best and worst.
closest = np.min(mapping, axis=1)			#For each image: Smallest distance
coords = np.argsort(mapping, axis=1)[:,0]	#For each image: The prototype ID
ids = np.argsort(closest)[::-1]			    #Image IDs ordered by min distance


# For each class as defined by PINK with a prototypical image, the collection of matching
# images is read in as an array of matching indices.
classes = []
for n in range(numPrototypes):
	collection = []
	for i in range(numImgs):
		if (coords[i] == n):
			collection.append(i)
	collection = np.array(collection)
	classes.append(collection)
classes = np.array(classes)			#Array of arrays (not matrix, variable
									#length 2nd dimension) with each the
									#collection of images in that class
			
            
#Number of images in each class:
imagesInClass = np.array( [ len(a) for a in classes ] )

print("Images divided into classes according to " + str(numPrototypes) + " prototypes.")
print("Classes contain between " + str(min(imagesInClass)) + " and " + str(max(imagesInClass)) + " images each.")

print("\nObtaining object coordinates:\n")

print("Loading image-matched catalogue...")
cat = np.loadtxt(imageCat, delimiter = ',', skiprows = 1, usecols = [0, 1])
ra, dec = cat[:,0], cat[:,1]

ra = np.array(ra)
dec = np.array(dec)

print("Loading astronomical data:")

hduPSM = fits.open(smassCat) #info in hdu[1]
dat = hduPSM[1].data

# Arrays to hold data from catalogue
cra = []		#3
cdec = []		#4
csfr = []		#18
cage = []		#11
clmass = []	    #15
cmet = []		#37
cz = []		    #5

count = 0

# Load the data
for e in dat:
	cra.append(e[3])
	cdec.append(e[4])
	cage.append(e[11])
	clmass.append(e[15])
	csfr.append(e[18])
	#cmet.append(e[37])
	cz.append(e[5])
	
	count += 1
	if count%50000 == 0:
		print(str(count) + " loaded...")
		

#Determine which information is actually useful.
print("\nData loaded. Extracting required information:\n")

cindices = []
cra = np.array(cra)
cdec = np.array(cdec)
cage = np.array(cage)
clmass = np.array(clmass)
csfr = np.array(csfr)
cz = np.array(cz)
#cmet = np.array(cmet)

#Cut down the array to more manageable size
rmin = min(ra) - precision
rmax = max(ra) + precision
dmin = min(dec) - precision
dmax = max(dec) + precision

print("Reducing to data for sources in rectangle: ("+str(rmin)+", "+str(dmin)+") to ("+str(rmax)+", "+str(dmax)+").")

#Exclude anything out of range
ind = np.where( ( cdec >= dmin ) & ( cdec <= dmax ) == True )[0]
cra = cra[ind]
cdec = cdec[ind]
csfr = csfr[ind]			#18
cage = cage[ind]		#11
clmass = clmass[ind]	#15
#cmet = cmet[ind]		#37
cz = cz[ind]			#5

ind = np.where(  (cra>=rmin) & (cra<=rmax) == True  )[0]
cra = cra[ind]
cdec = cdec[ind]
csfr = csfr[ind]		#18
cage = cage[ind]		#11
clmass = clmass[ind]	#15
#cmet = cmet[ind]		#37
cz = cz[ind]			#5

# Find the values for the sources in the catalogue
print("Finding average values and standard deviation for each class:")

# Arrays to hold average and Std. Dev. with an entry for each prototype.
classRA = []
classDEC = []
classRA_STD = []
classDEC_STD = []

classSFR = []
classSFR_STD = []

classAGE = []
classAGE_STD = []

classLMASS = []
classLMASS_STD = []

classZ = []
classZ_STD = []

allAGE = []
allLMASS = []
allZ = []
allRA = []
allDEC = []

#Then, for each class get the data for its objects

foundbc = np.zeros((numPrototypes,), dtype=int)
found = 0
nfound = 0
pnum = 0
for c in classes:
	
    print("For protoptype number " +str(pnum+1)+ "/" +str(len(classes))+ " ("+str(imagesInClass[pnum]) +" sources):")
    
    
    SFR = []
    AGE = []
    LMASS = []
    Z = []
    RA = []
    DEC = []
    
    for o in c:
    
        r = ra[o]
        d = dec[o]
        
        RA.append(r)
        DEC.append(d)
        
        allRA.append(r)
        allDEC.append(d)
        
        #Find a sufficiently close detection in SDSS.
        nfound += 1
        for c in range(len(cra)):
            if ( ( abs(cra[c]-r) <= precision ) and ( abs(cdec[c]-d) <= precision ) ):
                SFR.append(csfr[c])
                
                AGE.append(cage[c])
                allAGE.append(cage[c])
                
                LMASS.append(clmass[c])
                allLMASS.append(clmass[c])
                
                Z.append(cz[c])
                allZ.append(cz[c])
                
                found += 1
                foundbc[pnum] += 1
                nfound -=1
                break;
    
    
    SFR = np.array(SFR)
    AGE = np.array(AGE)
    LMASS = np.array(LMASS)
    Z = np.array(Z)
    
    RA = np.array(RA)
    DEC = np.array(DEC)
    
    if( len(SFR) == 0 ):
        print("WARNING:\tNo data held for sources.")
        print("\t\tAll means and Std.Dev. will be NaN.\n")
    
    # Find means and Std. Dev for this cell.
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=RuntimeWarning)
         
        classRA.append( np.nanmean(RA) )
        classRA_STD.append( np.nanstd(RA) )
        classDEC.append( np.nanmean(DEC) )
        classDEC_STD.append( np.nanstd(DEC) ) 
        
        classSFR.append( np.nanmean(SFR) )
        classSFR_STD.append( np.std(SFR) )
        
        print("SFR: " + str(classSFR[-1]) + ", St.D: " + str(classSFR_STD[-1]) )
        
        classAGE.append( np.nanmean(AGE) )
        classAGE_STD.append( np.nanstd(AGE) )
        
        print("AGE: " + str(classAGE[-1]) + ", St.D: " + str(classAGE_STD[-1]) )
        
        classLMASS.append( np.nanmean(LMASS) )
        classLMASS_STD.append( np.nanstd(LMASS) )
        
        print("LMASS: " + str(classLMASS[-1]) + ", St.D: " + str(classLMASS_STD[-1]) )
        
        classZ.append( np.nanmean(Z) )
        classZ_STD.append( np.nanstd(Z) )
        
        print("Z: " + str(classZ[-1]) + ", St.D: " + str(classZ_STD[-1]) + "\n")
        
    pnum += 1

print("\nData found: " + str(found))
print("Data not found:" + str(nfound))

print("\nGenerating data heatmaps:")

genStd = np.zeros(len(classZ))

print("Z...")
writeHeatmap(classZ, genStd, "heatmaps/z_mean.bin")
writeHeatmap(classZ_STD, genStd, "heatmaps/z_std.bin")
writeHeatmap(classZ, classZ_STD, "heatmaps/z_combined.bin")

print("AGE...")
writeHeatmap(classAGE, genStd, "heatmaps/age_mean.bin")
writeHeatmap(classAGE_STD, genStd, "heatmaps/age_std.bin")
writeHeatmap(classAGE, classAGE_STD, "heatmaps/age_combined.bin")

print("LnMass...")
writeHeatmap(classLMASS, genStd, "heatmaps/logmass_mean.bin")
writeHeatmap(classLMASS_STD, genStd, "heatmaps/logmass_std.bin")
writeHeatmap(classLMASS, classLMASS_STD, "heatmaps/logmass_combined.bin")

print("Source frequency...")
writeHeatmap(imagesInClass, genStd, "heatmaps/numsources.bin")

print("LnSource frequency...")

# Calculate the natural logarithm for the number of sources
lnNoImgs = np.ones(len(imagesInClass))
n = np.where( imagesInClass > 0 )[0]
lnNoImgs[n] = imagesInClass[n]
lnNoImgs = np.log(lnNoImgs) 

writeHeatmap(lnNoImgs, genStd, "heatmaps/lnnumsources.bin")

#Get avg RA and Dec and St.Dev.
print("Right Ascension...")
writeHeatmap(classRA, genStd, "heatmaps/ra_mean.bin")
writeHeatmap(classRA_STD, genStd, "heatmaps/ra_std.bin")
writeHeatmap(classRA, classRA_STD, "heatmaps/ra_combined.bin")

print("Declination...")
writeHeatmap(classDEC, genStd, "heatmaps/dec_mean.bin")
writeHeatmap(classDEC_STD, genStd, "heatmaps/dec_std.bin")
writeHeatmap(classDEC, classDEC_STD, "heatmaps/dec_combined.bin")

#Save the means and st. dev. so that it may be viewed or used by further scripts if required.
print("\nWriting means and standard deviations to file...")

data = []
hdr = "Class,Name,Mean,Std.Dv"

for i in range(len(classZ)): data.append( [ str(i),"Z", str(classZ[i]), str(classZ_STD[i]) ] )
for i in range(len(classAGE)): data.append( [ str(i),"AGE", str(classAGE[i]), str(classAGE_STD[i]) ] )
for i in range(len(classLMASS)): data.append( [ str(i),"LOGMASS", str(classLMASS[i]), str(classLMASS_STD[i]) ] )
for i in range(len(classRA)): data.append( [ str(i),"RA", str(classRA[i]), str(classRA_STD[i]) ] )
for i in range(len(classDEC)): data.append( [ str(i),"DEC", str(classDEC[i]), str(classDEC_STD[i]) ] )

data = np.array(data)
np.savetxt("classData.csv", data, fmt="%s", delimiter=",", newline="\n", header = hdr, comments="#")
